#pragma once

#include <vector>
#include <functional>
#include <chrono>
#include <thread>
#include <atomic>
#include "LaserPoint.hpp"

namespace libera::core {

/**
 * @brief Information provided when the controller asks for new points.
 */
struct PointFillRequest {
    /// Minimum number of points that must be produced by the callback.
    std::size_t minimumPointsRequired = 0;

    /// Maximum number of points that should be produced by the callback.
    /// A value of 0 means "no upper bound"; callers can tighten this to cap
    /// buffer growth when device FIFO space is limited.
    std::size_t maximumPointsRequired = 0;

    /// Host-side estimate of when the first point in this batch will reach the mirrors.
    /// (This is advisory â€” implementations can ignore or use it for scheduling.)
    std::chrono::steady_clock::time_point estimatedFirstPointRenderTime{};

    std::uint64_t currentPointIndex = 0; // absolute running counter

    bool needsPoints(std::size_t minPoints) { 
        return (minimumPointsRequired>minPoints) || (maximumPointsRequired>minPoints); 
    }
};

/**
 * @brief Callback contract for point generation.
 *
 * The callback must:
 * - Append new points to @p outputBuffer using `push_back` / `emplace_back`.
 * - Produce at least `request.minimumPointsRequired` points.
 * - Produce no more than `request.maximumPointsRequired` when it is non-zero.
 * - Not call `reserve()` or `resize()` on @p outputBuffer (avoid allocations
 *   inside the realtime path; the framework reserves large buffers up front).
 * - It may produce more than the minimum, up to outputBuffer.capacity().
 *
 * The caller reads outputBuffer.size() after the callback to know how many
 * points were written.
 */
using RequestPointsCallback =
    std::function<void(const PointFillRequest &request,
                       std::vector<LaserPoint> &outputBuffer)>;

/**
 * @brief Base controller class that manages callback-driven point generation.
 *
 * Subclasses (e.g. EtherDreamController, HeliosController) are responsible
 * for actually sending points to hardware. This base class only handles:
 * - Storing a user-provided callback.
 * - Requesting batches of new points via requestPoints().
 * - Accumulating generated points into an internal buffer for later use.
 *
 * Threading model:
 * - Base manages a worker thread that calls virtual `run()` until `stop()`.
 * - Derived classes implement `run()` (e.g., poll status, send points).
 * - `running` is an atomic flag checked by the loop.
 */
class LaserDeviceBase {
public:
    /**
     * @brief Construct the controller and reserve internal buffers.
     *
     * Currently reserves ~30k points for the transmission buffer, which is
     * more than most hardware FIFOs. This avoids most reallocations in practice.
     */
    LaserDeviceBase();
    virtual ~LaserDeviceBase();
    /**
     * @brief Install or replace the callback that generates points.
     * @param callback Function object or lambda conforming to RequestPointsCallback.
     */
    void setRequestPointsCallback(const RequestPointsCallback &callback);

    /**
     * @brief Ask the callback for more points and append them to the main buffer.
     *
     * Typical usage is from a hardware-specific run loop: call requestPoints() to
     * invoke the user-supplied callback, then send pointsToSend to the DAC.
     *
     * @param request Fill request (min points required, estimated render time).
     * @return false if no callback is installed, true if points were appended.
     */
    bool requestPoints(const PointFillRequest &request);


     /// Start the worker thread.
    void start();

    /// Request the thread to stop and wait for it to finish.
    void stop();

    /**
     * @brief Set the target latency budget between point submission and playback (milliseconds).
     *
     * Derived devices use this to size refill batches and tune socket timeouts.
     * Values less than 1 ms are clamped to 1 to avoid zero-length deadlines.
     */
    void setLatency(long long latencyMillisValue);

    /**
     * @brief Retrieve the currently configured latency budget in milliseconds.
     */
    long long getLatency() const;

protected:


    virtual void run() = 0; // the worker loop

    /// Latency (defaults to 50 ms). 
    std::atomic<long long> latencyMillis{50};

    std::thread worker;
    std::atomic<bool> running{false};

    /// The installed callback that generates points (may be empty if not set).
    RequestPointsCallback requestPointsCallback{};

    /// Main buffer of points pending transmission to the DAC.
    std::vector<LaserPoint> pointsToSend;


};

} // namespace libera::core
